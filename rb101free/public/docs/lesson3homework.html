<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Lesson Three Homework</title>
</head>

<body>

<p><b><font size="5">Lesson Three Homework</font></b><br>
Copyright 2007 Shoptalk Systems<br>
All Rights Reserved</p>

<p align="right"><a href="learnrunbasic.html">Return to Table of Contents</a></p>
<p>So far we covered the OUTPUT and INPUT file modes. These are for writing and 
reading files, respectively. This part of the lesson covers a new file mode 
called APPEND. We will also learn how to use the LINE INPUT statement, and we 
will also use a few other new Run BASIC statements in passing.<br>
<br>
<b><font size="4">The APPEND file mode</font></b><br>
<br>
There is a limitation in the OUTPUT file mode. The OUTPUT mode is only good for 
creating new files because it always deletes the contents of any file opened 
when it is used. For example:<br>
<br>
<font face="Courier New" size="2">&nbsp; 'open a file and print some information 
into it<br>
&nbsp; open &quot;numbers.txt&quot; for output as #numbers<br>
&nbsp; for x = 1 to 10<br>
&nbsp;&nbsp;&nbsp; print #numbers, x<br>
&nbsp; next x<br>
&nbsp; close #numbers<br>
<br>
&nbsp; 'now rewrite the file, replacing its original contents<br>
&nbsp; open &quot;numbers.txt&quot; for output as #numbers<br>
&nbsp; for x = 11 to 20<br>
&nbsp;&nbsp;&nbsp; print #numbers, x<br>
&nbsp; next x<br>
&nbsp; close #numbers<br>
&nbsp; end</font><br>
<br>
Run the above program and open Notepad on NUMBERS.TXT. You'll see that only the 
numbers 11 to 20 will be in the file. The only way to retain the original 
information in the file and add new information using the OUTPUT mode would be 
to read the original information and insert it into a new file. Then the new 
information is inserted into the still open file. Here is what that code looks 
like:<br>
<br>
<font face="Courier New" size="2">&nbsp; 'open a file, and print some 
information into it, then close it<br>
&nbsp; open &quot;numbers.txt&quot; for output as #numbers<br>
&nbsp; for x = 1 to 10<br>
&nbsp;&nbsp;&nbsp; print #numbers, x<br>
&nbsp; next x<br>
&nbsp; close #numbers<br>
<br>
&nbsp; 'open the original file for input<br>
&nbsp; open &quot;numbers.txt&quot; for input as #in<br>
&nbsp; 'open the new file for output<br>
&nbsp; open &quot;numbers2.txt&quot; for output as #numbers<br>
<br>
[copyLoop] 'copy the contents of numbers.txt to numbers2.txt<br>
&nbsp; if eof(#in) then [doneCopying] 'we reached the end of the file<br>
&nbsp; input #in, value<br>
&nbsp; print #numbers, value<br>
&nbsp; goto [copyLoop]<br>
<br>
[doneCopying] 'close numbers.txt &amp; print new numbers into numbers2.txt<br>
&nbsp; close #in<br>
&nbsp; for x = 11 to 20<br>
&nbsp;&nbsp;&nbsp; print #numbers, x<br>
&nbsp; next x<br>
&nbsp; close #numbers<br>
<br>
&nbsp; 'delete the original numbers.txt file<br>
&nbsp; kill &quot;numbers.txt&quot;<br>
&nbsp; 'rename numbers2.txt to numbers.txt<br>
&nbsp; name &quot;numbers2.txt&quot; as &quot;numbers.txt&quot;<br>
&nbsp; end<br>
</font><br>
Once the new file has been created containing the contents of the original file, 
plus our new numbers 11 to 20, we delete the old file using the KILL statement 
and rename the new file using the NAME statement.<br>
<br>
There is a better way. Using the APPEND file mode, we can eliminate a lot of 
program code. The APPEND mode opens a file for writing, just like the OUTPUT 
mode does. Instead of erasing the contents of the file opened and starting at 
the beginning, the APPEND mode opens a file and retains everything. All we need 
to do then is write to the file, and everything we write will be added to the 
end of the file. Here is the example above rewritten using the APPEND mode:<br>
<br>
<font face="Courier New" size="2">&nbsp; 'open a file, and print some 
information into it, then close it<br>
&nbsp; open &quot;numbers.txt&quot; for output as #numbers<br>
&nbsp; for x = 1 to 10<br>
&nbsp;&nbsp;&nbsp; print #numbers, x<br>
&nbsp; next x<br>
&nbsp; close #numbers<br>
<br>
&nbsp; 'open the original file for append<br>
&nbsp; open &quot;numbers.txt&quot; for append as #numbers<br>
&nbsp; for x = 11 to 20<br>
&nbsp;&nbsp;&nbsp; print #numbers, x<br>
&nbsp; next x<br>
&nbsp; close #numbers<br>
&nbsp; end</font><br>
<br>
This is much shorter and simpler than the last example. When we are done writing 
the numbers 11 to 20 there is no need to delete or rename files.<br>
<br>
<b><font size="4">Comma delimited files<br>
</font></b><br>
By default, the standard way of reading from a sequential file using the INPUT 
statement breaks up the data we read at each end of line, and at each comma. 
Look at these equivalent file contents:<br>
<br>
File 1 contents:<br>
<br>
<font face="Courier New" size="2">1,2,3,4,5,6,7,8,9,10</font><br>
<br>
File 2 contents:<br>
<br>
<font face="Courier New" size="2">1,2,3,4,5<br>
6,7,8,9,10</font><br>
<br>
File 3 contents:<br>
<br>
<font face="Courier New" size="2">1<br>
2<br>
3<br>
4<br>
5<br>
6<br>
7<br>
8<br>
9<br>
10</font><br>
<br>
All three of the above possible file contents would produce the same displayed 
output using a loop like the following:<br>
<br>
<font face="Courier New" size="2">[loop] 'display each item on its own line<br>
&nbsp; if eof(#in) then [stopLooping]<br>
&nbsp; input #in, item$ 'read the next item<br>
&nbsp; print item$<br>
&nbsp; goto [loop]</font><br>
<br>
Since the comma is used to separate items (in addition to the end of line), this 
kind of file format is often called 'comma delimited'. This is a preferred 
generic format often used by commercial application software (spreadsheets are a 
good example) as a data export option. This is so that people like you and me 
can write our own customized software to use that information.<br>
<br>
What if we want to use commas in our information? As an example, we decide that 
we will build an application that logs responses to a direct mail campaign, and 
we want the name to be entered in a single field. The name will be entered last 
name first, with a comma separating the last from the first name (example: Doe, 
John).<br>
<br>
Take a look at this hypothetical file entry:<br>
<br>
<font face="Courier New" size="2">Doe, John<br>
123 Main Street<br>
Scottsdale<br>
AZ<br>
01234</font><br>
<br>
Now look at this code fragment:<br>
<br>
<font face="Courier New" size="2">&nbsp; input #in, name$<br>
&nbsp; input #in, street$<br>
&nbsp; input #in, city$<br>
&nbsp; input #in, state$<br>
&nbsp; input #in, zip$</font><br>
<br>
If we read the file entry with the above code, name$ would only contain up to 
the first comma. So name$ would contain the string &quot;Doe&quot;, street$ would contain 
&quot;John&quot;, city$ would contain &quot;123 Main Street&quot;, and so on. This is<br>
not what we want. <br>
<br>
There is a special form of the INPUT statement that will read a whole line from 
a file, including commas. It is the LINE INPUT statement. Here is the code 
fragment above rewritten using LINE INPUT:<br>
<br>
<font face="Courier New" size="2">&nbsp; line input #in, name$<br>
&nbsp; line input #in, street$<br>
&nbsp; line input #in, city$<br>
&nbsp; line input #in, state$<br>
&nbsp; line input #in, zip$</font><br>
<br>
Another example of where LINE INPUT is useful is reading of a text document, 
like this one. There are many commas in this document. Here is a short program 
that uses the FILEDIALOG statement to ask for a *.txt file to read. Then it 
opens the file and reads and displays it.<br>
<br>
<font face="Courier New" size="2">&nbsp; 'ask for a filename<br>
&nbsp; filedialog &quot;Select a text file&quot;, &quot;*.TXT&quot;, filename$<br>
<br>
&nbsp; 'if filename$ = &quot;&quot; then the user canceled the file selection<br>
&nbsp; if filename$ = &quot;&quot; then end<br>
<br>
&nbsp; 'open the file<br>
&nbsp; open filename$ for input as #in<br>
<br>
[readLoop] 'read and display each line in the text file<br>
&nbsp; if eof(#in) then [stopLooping]<br>
&nbsp; line input #in, lineOfText$<br>
&nbsp; print lineOfText$<br>
&nbsp; goto [readLoop]<br>
<br>
[stopLooping] 'close the file<br>
&nbsp; close #in<br>
&nbsp; end<br>
</font><br>
Run this small program and try it with a file that you know has some commas in 
it. Then change the line containing the LINE INPUT statement to use a regular 
INPUT statement and run the program again on the same file so you can see how 
they function differently. <br>
<br>
<font face="Times New Roman" size="4"><b>Here's the assignment</b></font><br>
<br>
Create a program called CALLER.BAS. This program will give the user the 
following options:<br>
<br>
1) Enter a phone call<br>
2) Search by caller's name<br>
3) Search by person called<br>
3) Quit<br>
<br>
Menu item 1 will ask the user for phone call information and append it as a new 
record to the end of a file named PHONELOG.TXT. The added record must include:<br>
<br>
1) Caller's name<br>
2) Name of person called<br>
3) Date of the call<br>
4) Time of the call<br>
5) A one line description of the call's purpose<br>
6) A phone # where the caller can be reached<br>
<br>
When searching, the program should stop and display the six data items for each 
record that matches and ask if the user wants to keep searching or quit the 
search. The program will display a notice if no matches are found.<br>
<br>
<b><font size="4">Possible enhancement to CALLER.BAS</font></b><br>
<br>
It is possible to search for a partial match. Look at the following code 
example:<br>
<br>
<font face="Courier New" size="2">&nbsp; text$ = &quot;The quick brown fox jumped 
over the lazy dog.&quot;<br>
&nbsp; searchFor$ = &quot;FOX&quot; 'change FOX to different values and re-run<br>
&nbsp; print &quot;Searching for:&quot;<br>
&nbsp; print &quot; &quot;; searchFor$<br>
&nbsp; print &quot;In the following:&quot;<br>
&nbsp; print &quot; &quot;; text$<br>
&nbsp; a$ = upper$(text$)<br>
&nbsp; b$ = upper$(searchFor$)<br>
&nbsp; if instr(a$, b$) &gt; 0 then print &quot;Found!&quot; else print &quot;Not Found!&quot;</font><br>
<br>
The UPPER$() function eliminates any letter case differences. The INSTR() 
function returns a 0 value if our uppercased searchFor$ is not found in our 
uppercased text, or it returns the position of searchFor$ if it is found.</p>

</body>

</html>