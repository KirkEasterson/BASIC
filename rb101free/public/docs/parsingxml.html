<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>New Page 1</title>
<style>
<!--
div{color:#000}.g{margin:1em 0}td{color:#000}.j{width:34em}-->
</style>
</head>

<body>

<p><b><font size="5">Parsing XML</font></b></p>
<p align="right"><a href="rbhelp.html">Jump to Run BASIC Help File</a></p>
<p><a href="#getAccessor">Getting an XML accessor</a><br>
<a href="#attributes">Accessing element attributes</a><br>
<a href="#errorHandling">Error handling</a><br>
<a href="#xmlparserMethods">XMLPARSER methods</a></p>
<p>Run BASIC includes a non-validating XML parser.&nbsp; This can useful for various things 
including working with information that you retrieve from the web using Run 
BASIC's httpget function.</p>
<p><b><a name="getAccessor"></a>Getting an XML accessor</b></p>
<p>Use get an XML accessor object, use the XMLPARSER statement.&nbsp; You 
specify an object variable name and a string expression, like so:</p>
<p><font face="Courier New" size="2">xmlparser #accessor, &quot;&lt;someTag&gt;attr=&quot;&quot;some text&quot;&quot;&lt;/someTag&gt;&quot;</font></p>

<p>The resulting parsed XML can be read from the object in #accessor.&nbsp; 
Here's an example that reads some simple XML (line breaks are allowed in RB 
string literals):</p>
<p><font face="Courier New" size="2">xml$ = &quot;&lt;group&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;customer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;name&gt;Fred Jones&lt;/name&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;email&gt;fj@mail.com&lt;/email&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;phone&gt;234-3456&lt;/phone&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;/customer&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;customer&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;name&gt;Ed Black&lt;/name&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;email&gt;eb@mail.com&lt;/email&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;phone&gt;123-2345&lt;/phone&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;/customer&gt;<br>
&lt;/group&gt;&quot;<br>
xmlparser #accessor, xml$<br>
print &quot;Contents of &lt;&quot;+#accessor key$()+&quot;&gt;&quot;<br>
for i = 1 to #accessor elementcount()<br>
&nbsp; #customer = #accessor #element(i)<br>
&nbsp; print &quot;Customer: &quot;;<br>
&nbsp; print #customer valueforkey$(&quot;name&quot;); &quot;, &quot;;<br>
&nbsp; print #customer valueforkey$(&quot;email&quot;); &quot;, &quot;;<br>
&nbsp; print #customer valueforkey$(&quot;phone&quot;)<br>
next i</font></p>
<p><font face="Times New Roman">The output of this example is:</font></p>
<blockquote>
  <p><font face="Courier New" size="2">Contents of &lt;group&gt;<br>
  Customer: Fred Jones, fj@mail.com, 234-3456<br>
  Customer: Ed Black, eb@mail.com, 123-2345</font></p>
</blockquote>
<p>When the XMLPARSER statement is executed in the example, the #accessor object 
is returned on the highest level XML element &lt;group&gt;.&nbsp; Notice that we used 
the KEY$() method to get the name of that element to print it out.</p>
<p>Then used the ELEMENTSCOUNT() method and a FOR/NEXT loop to access the two 
&lt;customer&gt; elements.&nbsp; The VALUEFORKEY$() method is used to get the string 
value for each of the contained tags &lt;name&gt;, &lt;email&gt;, and &lt;phone&gt;.</p>
<p><font face="Times New Roman">Since we have the #customer object, we could 
also use the ELEMENTSCOUNT() and ELEMENT() methods to access each tag as an 
object in this fashion which produces identical output as the code above:</font></p>
<p><font face="Courier New" size="2">for i = 1 to #accessor elementcount()<br>
&nbsp; #customer = #accessor #element(i)<br>
&nbsp; print &quot;Customer: &quot;;<br>
&nbsp; for c = 1 to #customer elementcount()<br>
&nbsp;&nbsp;&nbsp; #item = #customer #element(c)<br>
&nbsp;&nbsp;&nbsp; print #item value$();<br>
&nbsp;&nbsp;&nbsp; if c &lt; #customer elementcount() then print &quot;, &quot;;<br>
&nbsp; next c<br>
&nbsp; print<br>
next i</font></p>
<p><b><font face="Times New Roman"><a name="attributes"></a>Accessing element 
attributes</font></b></p>
<p><font face="Times New Roman">XML elements can also have attibutes in addition 
to tag names and values.&nbsp; For example a common tag seen in web page source 
code:</font></p>
<p><font face="Courier New" size="2">&nbsp; &lt;a href = &quot;http://www.runbasic.com&quot;
</font><font size="-1" face="Courier New">target=&quot;_blank&quot;</font><font face="Courier New" size="2">&gt;The 
Run BASIC site&lt;/a&gt;</font></p>
<p><font face="Times New Roman">To read the HREF and TARGET attributes you can 
use the ATTRIBCOUNT(), ATTRIBKEY$(), ATTRIBVALUE$() methods.&nbsp; Here is an 
example:</font></p>
<p><font face="Courier New" size="2">xml$=&quot;&lt;a href = &quot;&quot;http://www.runbasic.com&quot;&quot; 
target=&quot;&quot;_blank&quot;&quot;&gt;<br>
The Run BASIC site<br>
&lt;/a&gt;&quot;<br>
xmlparser #href, xml$<br>
for x = 1 to #href attribcount()<br>
&nbsp; print #href attribkey$(x);&quot;, &quot;; #href attribvalue$(x)<br>
next x</font></p>
<p><b><font face="Times New Roman"><a name="errorHandling"></a>Error handling</font></b></p>
<p><font face="Times New Roman">If the XMLPARSER statement attempts to parse 
malformed XML it will throw a runtime error, bringing your web application to a 
halt.&nbsp; The way to deal with this is to use ON ERROR GOTO to set up an error 
handler.&nbsp; Here is an example:</font></p>
<p><font face="Courier New" size="2">&nbsp; xml$=&quot;&lt;a href = 
&quot;&quot;http://www.runbasic.com&quot;&quot; target=&quot;&quot;_blank&quot;&quot;&gt;<br>
The Run BASIC site&quot;<br>
<br>
[parseIt]<br>
&nbsp; on error goto [parsingFailed]<br>
&nbsp; xmlparser #href, xml$<br>
&nbsp; for x = 1 to #href attribcount()<br>
&nbsp; print #href attribkey$(x);&quot;, &quot;; #href attribvalue$(x)<br>
&nbsp; next x<br>
&nbsp; end<br>
<br>
[parsingFailed]<br>
&nbsp; print Err$<br>
&nbsp; print &quot;Adding &lt;/a&gt; tag and retrying.&quot;<br>
&nbsp; xml$ = xml$ + &quot;&lt;/a&gt;&quot;<br>
&nbsp; goto [parseIt]</font></p>

<p><b><a name="xmlparserMethods"></a>XMLPARSER methods</b></p>

<p>#handle ELEMENTCOUNT() - Return the number of child XML 
elements<br>
#handle KEY$() - Return the key as a string from an XML expression like 
&lt;key&gt;value&lt;/key&gt;<br>
#handle VALUE$() - Return the value as a string from an XML expression like 
&lt;key&gt;value&lt;/key&gt;<br>
#handle VALUEFORKEY$(keyExpr$) - Return the value for the specified tag key in 
keyExpr$<br>
#handle #ELEMENT(n) - Return the nth child-element XML element <br>
#handle #ELEMENT(nameExpr$) - Return the child-element XML element named by 
nameExpr$<br>
#handle ATTRIBCOUNT() - Return a count of attribute pairs;&nbsp; &lt;a attrA=&quot;abc&quot; 
attrB=&quot;def&quot;&gt; has two pairs<br>
#handle ATTRIBKEY$(n) - Return the key string of the nth attribute<br>
#handle ATTRIBVALUE$(n) - Return the value string of the nth attribute<br>
#handle ATTRIBVALUE$(n$) - Return the value string of the attribute with the key 
n$, or an empty string if it doesn't exist.<br>
#handle ISNULL() - Returns zero (or false)<br>
#handle DEBUG$() - Returns the string &quot;Xmlparser&quot;</p>

</body>

</html>